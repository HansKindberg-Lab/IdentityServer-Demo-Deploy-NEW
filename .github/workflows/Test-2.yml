name: "A"

on:
  #push:
  #  branches: [ master ]
  workflow_dispatch:

env:
  SQLSERVER_INSTANCE: "${{ secrets.SQLSERVER_NAME }}.database.windows.net"

jobs:
  A:
    name: "A"
    runs-on: "ubuntu-latest"
    steps:
      - name: "Ensure user & owner for database"
        env:
          ENSURE_USER_SQL: |
            IF NOT EXISTS(SELECT [name] FROM [sys].[sql_logins] WHERE [name] = '${{ secrets.DATABASE_USER }}')
            BEGIN
              SELECT 'Creating login ''${{ secrets.DATABASE_USER }}''...' AS 'Output';
              EXECUTE ('CREATE LOGIN [${{ secrets.DATABASE_USER }}] WITH PASSWORD = ''${{ secrets.DATABASE_USER_PASSWORD }}'';');
            END
            ELSE
            BEGIN
              SELECT 'The login ''${{ secrets.DATABASE_USER }}'' already exists.' AS 'Output';
            END
          ENSURE_OWNER_SQL: |
            IF NOT EXISTS (SELECT [name] FROM [sys].[database_principals] WHERE [name] = '${{ secrets.DATABASE_USER }}' AND [type] = 'S')
            BEGIN
              SELECT 'Setting ''${{ secrets.DATABASE_USER }}'' as owner for database ''${{ secrets.DATABASE_NAME }}''...' AS 'Output';
              EXECUTE ('CREATE USER [${{ secrets.DATABASE_USER }}] FOR LOGIN [${{ secrets.DATABASE_USER }}];');
              EXECUTE ('ALTER ROLE [db_owner] ADD MEMBER [${{ secrets.DATABASE_USER }}];');
            END
            ELSE
            BEGIN
              SELECT '''${{ secrets.DATABASE_USER }}'' is already owner for database ''${{ secrets.DATABASE_NAME }}''.' AS 'Output';
            END
        run: |
          Install-Module -Force -Name SqlServer -Repository PSGallery;
          Import-Module SqlServer;
          $note = "Instead of using -Credential we could also use -Password & -Username, but if doing so and the login fails the password gets exposed in the console when the error is written."
          $securePassword = ConvertTo-SecureString '${{ secrets.SQLSERVER_ADMINISTRATOR_PASSWORD }}' -AsPlainText -Force;
          $credential = [PSCredential]::New("${{ secrets.SQLSERVER_ADMINISTRATOR }}", $securePassword);
          Invoke-Sqlcmd -Credential $credential -Database "master" -Query "${{ env.ENSURE_USER_SQL }}" -ServerInstance "${{ env.SQLSERVER_INSTANCE }}";
          Invoke-Sqlcmd -Credential $credential -Database "${{ secrets.DATABASE_NAME }}" -Query "${{ env.ENSURE_OWNER_SQL }}" -ServerInstance "${{ env.SQLSERVER_INSTANCE }}";
        shell: pwsh